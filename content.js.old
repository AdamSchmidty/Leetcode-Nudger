// ============================================================================
// LEETCODE BUDDY - CONTENT SCRIPT
// ============================================================================
// Runs on leetcode.com/problems/* pages to detect successful submissions
// and verify that problems were solved today before notifying background.
// ============================================================================

// ============================================================================
// STATE VARIABLES
// ============================================================================

let problemAliases = {};

// ============================================================================
// MESSAGING UTILITIES
// ============================================================================

/**
 * Safe message sending with context validation
 * @param {Object} message - Message object to send to background script
 * @returns {Promise<Object>} Response from background script
 */
async function sendMessageSafely(message) {
  try {
    // Check if extension context is still valid
    if (!chrome.runtime?.id) {
      console.warn("Extension context invalidated, skipping message");
      return { success: false, error: "Context invalidated" };
    }
    
    return await chrome.runtime.sendMessage(message);
  } catch (error) {
    if (error.message?.includes("Extension context invalidated") || 
        error.message?.includes("message port closed") ||
        error.message?.includes("Extension context")) {
      console.warn("Extension was reloaded, skipping message");
      return { success: false, error: "Context invalidated" };
    }
    console.error("Message sending failed:", error);
    throw error;
  }
}

// ============================================================================
// PROBLEM ALIAS RESOLUTION
// ============================================================================

/**
 * Load problem aliases mapping from assets
 * @returns {Promise<Object>} Aliases object
 */
async function loadAliases() {
  try {
    const response = await fetch(chrome.runtime.getURL("src/assets/data/problemAliases.json"));
    problemAliases = await response.json();
    return problemAliases;
  } catch (error) {
    console.error("Failed to load aliases:", error);
    return {};
  }
}

/**
 * Resolve alias to canonical LeetCode slug
 * @param {string} slug - Problem slug (may be alias)
 * @returns {string} Canonical slug
 */
function resolveAlias(slug) {
  return problemAliases[slug] || slug;
}

// Extract current problem slug from URL
function getCurrentSlug() {
  const match = window.location.pathname.match(/^\/problems\/([^/]+)\/?/);
  return match ? match[1] : null;
}

// Get current LeetCode username with retry logic
async function getCurrentUsername(retries = 2) {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      // First, try to get username from the page's global data
      const globalData = document.querySelector('script')?.textContent?.match(/username['"]\s*:\s*['"]([^'"]+)['"]/);
      if (globalData && globalData[1]) {
        console.log("‚úì Username found in page data:", globalData[1]);
        return globalData[1];
      }

      // Alternative: Query the whoami endpoint
      const query = `
        query globalData {
          userStatus {
            username
          }
        }
      `;

      const response = await fetch("https://leetcode.com/graphql", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-csrftoken": getCsrfToken(),
          Referer: window.location.href,
        },
        credentials: "include",
        body: JSON.stringify({ query }),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const username = data?.data?.userStatus?.username;
      
      if (username) {
        console.log("‚úì Username fetched from API:", username);
        return username;
      }
      
      // If no username found, throw to trigger retry
      throw new Error("Username not found in response");
      
    } catch (error) {
      console.error(`Username fetch attempt ${attempt + 1}/${retries} failed:`, error.message);
      
      if (attempt < retries - 1) {
        // Wait before retry (exponential backoff)
        const delay = 1000 * (attempt + 1);
        console.log(`Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  console.warn("‚ö† Failed to get username after all retries, using fallback");
  return null;
}

// Get CSRF token from cookies
function getCsrfToken() {
  const match = document.cookie.match(/csrftoken=([^;]+)/);
  return match ? match[1] : "";
}

// Query LeetCode GraphQL API for problem status
async function queryProblemStatus(slug) {
  try {
    const query = `
      query questionStatus($titleSlug: String!) {
        question(titleSlug: $titleSlug) {
          status
        }
      }
    `;

    const response = await fetch("https://leetcode.com/graphql", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-csrftoken": getCsrfToken(),
        Referer: window.location.href,
      },
      credentials: "include",
      body: JSON.stringify({
        query,
        variables: { titleSlug: slug },
      }),
    });

    const data = await response.json();
    return data?.data?.question?.status || null;
  } catch (error) {
    console.error("Failed to query problem status:", error);
    return null;
  }
}

// Query recent submissions with timestamps
async function queryRecentSubmissions(username, limit = 50) {
  try {
    const query = `
      query recentSubmissionList($username: String!, $limit: Int!) {
        recentSubmissionList(username: $username, limit: $limit) {
          titleSlug
          timestamp
          statusDisplay
          lang
        }
      }
    `;

    const response = await fetch("https://leetcode.com/graphql", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-csrftoken": getCsrfToken(),
        Referer: window.location.href,
      },
      credentials: "include",
      body: JSON.stringify({
        query,
        variables: { username, limit },
      }),
    });

    const data = await response.json();
    return data?.data?.recentSubmissionList || [];
  } catch (error) {
    console.error("Failed to query recent submissions:", error);
    return [];
  }
}

// Query submission history for a specific problem
async function queryProblemSubmissions(questionSlug, limit = 10) {
  try {
    const query = `
      query submissionList($offset: Int!, $limit: Int!, $questionSlug: String!) {
        submissionList(offset: $offset, limit: $limit, questionSlug: $questionSlug) {
          submissions {
            timestamp
            statusDisplay
            lang
          }
        }
      }
    `;

    const response = await fetch("https://leetcode.com/graphql", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-csrftoken": getCsrfToken(),
        Referer: window.location.href,
      },
      credentials: "include",
      body: JSON.stringify({
        query,
        variables: { offset: 0, limit, questionSlug },
      }),
    });

    const data = await response.json();
    return data?.data?.submissionList?.submissions || [];
  } catch (error) {
    console.error("Failed to query problem submissions:", error);
    return [];
  }
}

/**
 * Check if a timestamp is from today (local timezone)
 * @param {number} timestamp - Unix timestamp in seconds
 * @returns {boolean} True if timestamp is from today
 */
function isSolvedToday(timestamp) {
  if (!timestamp) return false;
  
  // Convert epoch seconds to Date
  const submissionDate = new Date(parseInt(timestamp) * 1000);
  const today = new Date();
  
  // Compare dates (ignore time)
  return (
    submissionDate.getFullYear() === today.getFullYear() &&
    submissionDate.getMonth() === today.getMonth() &&
    submissionDate.getDate() === today.getDate()
  );
}

// Check if the current problem is solved and notify background
async function checkAndNotify() {
  const slug = getCurrentSlug();
  if (!slug) {
    console.log("No problem slug found in URL");
    return;
  }

  // Resolve alias to canonical slug
  const canonicalSlug = resolveAlias(slug);
  console.log("Checking status for problem:", slug, "->", canonicalSlug);

  const status = await queryProblemStatus(canonicalSlug);

  console.log("Problem status:", status);

  if (status === "ac") {
    console.log("Problem is solved! Verifying solve date...");
    
    // Verify the problem was solved TODAY
    let solvedToday = false;
    let solveTimestamp = null;
    
    try {
      // Get username
      const username = await getCurrentUsername();
      
      if (username) {
        console.log("Username:", username);
        
        // First, try to find in recent submissions (faster)
        const recentSubmissions = await queryRecentSubmissions(username, 50);
        console.log(`Found ${recentSubmissions.length} recent submissions`);
        
        // Look for accepted submissions for this problem
        const acceptedSubmissions = recentSubmissions.filter(
          sub => sub.titleSlug === canonicalSlug && sub.statusDisplay === "Accepted"
        );
        
        if (acceptedSubmissions.length > 0) {
          // Check if any submission is from today
          const todaySubmission = acceptedSubmissions.find(sub => isSolvedToday(sub.timestamp));
          if (todaySubmission) {
            solvedToday = true;
            solveTimestamp = todaySubmission.timestamp;
            console.log("‚úì Found submission from today in recent submissions");
          }
        }
        
        // Fallback: If not in recent submissions, check problem-specific submission history
        if (!solvedToday) {
          console.log("Not in recent submissions, checking problem-specific history...");
          const problemSubmissions = await queryProblemSubmissions(canonicalSlug, 10);
          
          const todaySubmission = problemSubmissions.find(
            sub => sub.statusDisplay === "Accepted" && isSolvedToday(sub.timestamp)
          );
          
          if (todaySubmission) {
            solvedToday = true;
            solveTimestamp = todaySubmission.timestamp;
            console.log("‚úì Found submission from today in problem history");
          }
        }
      } else {
        console.warn("Could not get username, falling back to status-only check");
        // Fallback: If we can't get username, assume solved today
        solvedToday = true;
      }
    } catch (error) {
      console.error("Error verifying solve date:", error);
      // Fallback: On error, assume solved today to not block functionality
      solvedToday = true;
    }
    
    if (solvedToday) {
      console.log("‚úì Problem was solved TODAY! Checking if this is the expected problem...");
      
      // Get the current expected problem from background
      const statusResponse = await sendMessageSafely({ type: "GET_STATUS" });
      
      if (!statusResponse.success) {
        console.warn("Could not get current status, skipping daily solve check");
        return;
      }
      
      const expectedProblemSlug = statusResponse.currentProblem?.slug;
      
      if (canonicalSlug !== expectedProblemSlug) {
        console.log(`‚ÑπÔ∏è Problem solved today, but not the expected problem.`);
        console.log(`  Expected: ${expectedProblemSlug}, Solved: ${canonicalSlug}`);
        console.log("  This won't count as today's daily solve.");
        return;
      }
      
      console.log("‚úì This is the EXPECTED problem! Notifying background...");
      
      try {
        const response = await sendMessageSafely({
          type: "PROBLEM_SOLVED",
          slug: canonicalSlug,
          timestamp: solveTimestamp,
          verifiedToday: !!solveTimestamp,
        });
        
        // Check if extension context was invalidated
        if (!response.success && response.error === "Context invalidated") {
          console.log("Extension was reloaded, skipping celebration");
          return;
        }
        
        console.log("Background response:", response);

        if (response.dailySolved) {
          // Check if celebration has already been shown today
          const shouldShowCelebration = await checkIfShouldShowCelebration();
          
          if (shouldShowCelebration) {
            // Show notification and mark as shown
            showSolvedNotification();
            await markCelebrationAsShown();
          }
        }
      } catch (error) {
        console.error("Failed to notify background:", error);
      }
    } else {
      console.log("‚úó Problem was solved in the past, not counting as daily solve");
    }
  }
}

// ============================================================================
// CELEBRATION ANIMATIONS
// ============================================================================

// Check if celebration should be shown (only once per day and if enabled)
async function checkIfShouldShowCelebration() {
  try {
    // Check if celebrations are enabled in settings (default: true)
    const syncResult = await chrome.storage.sync.get(['celebrationEnabled']);
    const isEnabled = syncResult.celebrationEnabled !== false;
    
    if (!isEnabled) {
      console.log("Celebrations are disabled in settings");
      return false;
    }
    
    // Check if celebration has already been shown today
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const localResult = await chrome.storage.local.get(['celebrationShownDate']);
    
    // Show celebration if it hasn't been shown today and is enabled
    return localResult.celebrationShownDate !== today;
  } catch (error) {
    console.error("Failed to check celebration status:", error);
    return true; // Show on error to be safe
  }
}

// Mark celebration as shown for today
async function markCelebrationAsShown() {
  try {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    await chrome.storage.local.set({ celebrationShownDate: today });
    console.log("Celebration marked as shown for:", today);
  } catch (error) {
    console.error("Failed to mark celebration as shown:", error);
  }
}

// CSS-based confetti animation (no external dependencies)
function triggerConfetti() {
  const confettiContainer = document.createElement('div');
  confettiContainer.id = 'leetcode-buddy-confetti';
  confettiContainer.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10000;
    overflow: hidden;
  `;
  
  // Create confetti pieces
  const colors = ['#667eea', '#764ba2', '#10b981', '#f59e0b', '#ef4444', '#3b82f6', '#ec4899', '#8b5cf6'];
  const shapes = ['circle', 'square', 'triangle'];
  const confettiCount = 60;
  
  for (let i = 0; i < confettiCount; i++) {
    const confetti = document.createElement('div');
    const color = colors[Math.floor(Math.random() * colors.length)];
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    const left = Math.random() * 100;
    const animationDelay = Math.random() * 0.5;
    const animationDuration = 2.5 + Math.random() * 2;
    const size = 8 + Math.random() * 6;
    const rotation = Math.random() * 360;
    
    let shapeStyle = '';
    if (shape === 'circle') {
      shapeStyle = 'border-radius: 50%;';
    } else if (shape === 'triangle') {
      shapeStyle = `
        width: 0;
        height: 0;
        border-left: ${size/2}px solid transparent;
        border-right: ${size/2}px solid transparent;
        border-bottom: ${size}px solid ${color};
        background: transparent;
      `;
    }
    
    confetti.style.cssText = `
      position: absolute;
      left: ${left}%;
      top: -20px;
      width: ${shape === 'triangle' ? '0' : size + 'px'};
      height: ${shape === 'triangle' ? '0' : size + 'px'};
      background: ${shape === 'triangle' ? 'transparent' : color};
      ${shapeStyle}
      opacity: 0.9;
      animation: confettiFall ${animationDuration}s linear ${animationDelay}s forwards;
      transform: rotate(${rotation}deg);
      transform-origin: center;
    `;
    
    confettiContainer.appendChild(confetti);
  }
  
  // Add animation styles if not already added
  if (!document.getElementById('confetti-animation-styles')) {
    const style = document.createElement('style');
    style.id = 'confetti-animation-styles';
    style.textContent = `
      @keyframes confettiFall {
        0% {
          transform: translateY(0) rotateZ(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(100vh) rotateZ(720deg);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(confettiContainer);
  
  // Remove after animation
  setTimeout(() => {
    confettiContainer.remove();
  }, 5000);
}

// Show a notification when problem is solved
function showSolvedNotification() {
  // Trigger confetti celebration!
  triggerConfetti();
  
  const notification = document.createElement("div");
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    padding: 20px 24px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    z-index: 10002;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 16px;
    font-weight: 600;
    max-width: 350px;
    animation: slideIn 0.5s ease-out;
  `;
  notification.innerHTML = `
    <div style="margin-bottom: 8px; font-size: 32px; animation: bounce 0.6s ease-in-out;">üéâ</div>
    <div style="font-size: 18px; margin-bottom: 4px;">Amazing! Daily Problem Solved!</div>
    <div style="font-size: 14px; font-weight: 400; opacity: 0.95; margin-top: 6px;">
      All websites unblocked until midnight. Great work! üéä
    </div>
  `;

  // Add animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    @keyframes bounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }
  `;
  document.head.appendChild(style);
  document.body.appendChild(notification);

  // Remove notification after 6 seconds
  setTimeout(() => {
    notification.style.transition = "opacity 0.5s, transform 0.5s";
    notification.style.opacity = "0";
    notification.style.transform = "translateX(400px)";
    setTimeout(() => {
      notification.remove();
      style.remove();
    }, 500);
  }, 6000);
}

// Monitor for successful submissions
let lastPathname = window.location.pathname;
let checkTimeout = null;
let hasCheckedOnLoad = false;

// Watch for DOM changes that indicate a submission result
const observer = new MutationObserver((mutations) => {
  // Look for success indicators in the DOM
  const successElements = document.querySelectorAll(
    '[data-e2e-locator="submission-result"]'
  );

  for (const element of successElements) {
    const text = element.textContent || "";
    if (text.includes("Accepted") || text.includes("Success")) {
      console.log("Detected successful submission!");

      // Clear any pending check
      if (checkTimeout) {
        clearTimeout(checkTimeout);
      }

      // Check status after a short delay to let LeetCode update the backend
      checkTimeout = setTimeout(() => {
        checkAndNotify();
      }, 2000);

      break;
    }
  }
});

// Initialize with error boundaries
(async function initializeLeetcodeBuddy() {
  try {
    console.log("ü§ù Leetcode Buddy initializing...");
    
    // Load problem aliases
    await loadAliases();
    
    // Start observing the document for changes
    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });

    // Check periodically if URL changed (client-side navigation)
    setInterval(() => {
      try {
        if (window.location.pathname !== lastPathname) {
          console.log("URL changed, checking new problem...");
          lastPathname = window.location.pathname;
          hasCheckedOnLoad = false;

          // Check after a delay to let the page load
          setTimeout(() => {
            if (!hasCheckedOnLoad) {
              checkAndNotify();
              hasCheckedOnLoad = true;
            }
          }, 3000);
        }
      } catch (error) {
        console.error("Error in URL change handler:", error);
      }
    }, 1000);

    // Initial check when content script loads
    setTimeout(() => {
      try {
        if (!hasCheckedOnLoad) {
          console.log("Initial problem status check...");
          checkAndNotify();
          hasCheckedOnLoad = true;
        }
      } catch (error) {
        console.error("Error in initial check:", error);
      }
    }, 3000);

    // Listen for visibility changes (tab becomes active)
    document.addEventListener("visibilitychange", () => {
      try {
        if (!document.hidden) {
          console.log("Tab became visible, checking status...");
          setTimeout(checkAndNotify, 1000);
        }
      } catch (error) {
        console.error("Error in visibility change handler:", error);
      }
    });

    console.log("‚úì Leetcode Buddy content script loaded on:", window.location.href);
    
  } catch (error) {
    console.error("‚ùå Leetcode Buddy initialization error:", error);
    console.error("Stack trace:", error.stack);
  }
})();
